<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>EVM(以太坊虚拟机) | Chitian's Blogs</title><meta name="author" content="chitian-victor"><meta name="copyright" content="chitian-victor"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、定义EVM 全称是 Ethereum Virtual Machine ，具备以下特性：  虚拟运行环境： 它不直接运行在硬件上，而是作为一个软件层运行在每一个以太坊节点（计算机）中。 沙盒化（Sandboxed）： EVM 是完全隔离的。在 EVM 中运行的代码（智能合约）无法访问网络、文件系统或其他进程。这保证了即使合约有恶意代码，也不会损害节点本身。 统一性： 无论在 Windows、Li">
<meta property="og:type" content="article">
<meta property="og:title" content="EVM(以太坊虚拟机)">
<meta property="og:url" content="https://chitian-victor.github.io/2026/01/06/EVM/index.html">
<meta property="og:site_name" content="Chitian&#39;s Blogs">
<meta property="og:description" content="一、定义EVM 全称是 Ethereum Virtual Machine ，具备以下特性：  虚拟运行环境： 它不直接运行在硬件上，而是作为一个软件层运行在每一个以太坊节点（计算机）中。 沙盒化（Sandboxed）： EVM 是完全隔离的。在 EVM 中运行的代码（智能合约）无法访问网络、文件系统或其他进程。这保证了即使合约有恶意代码，也不会损害节点本身。 统一性： 无论在 Windows、Li">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chitian-victor.github.io/img/luffy-icon.png">
<meta property="article:published_time" content="2026-01-06T13:37:36.000Z">
<meta property="article:modified_time" content="2026-01-06T14:06:03.729Z">
<meta property="article:author" content="chitian-victor">
<meta property="article:tag" content="ethereum">
<meta property="article:tag" content="web3">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chitian-victor.github.io/img/luffy-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "EVM(以太坊虚拟机)",
  "url": "https://chitian-victor.github.io/2026/01/06/EVM/",
  "image": "https://chitian-victor.github.io/img/luffy-icon.png",
  "datePublished": "2026-01-06T13:37:36.000Z",
  "dateModified": "2026-01-06T14:06:03.729Z",
  "author": [
    {
      "@type": "Person",
      "name": "chitian-victor",
      "url": "https://chitian-victor.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://chitian-victor.github.io/2026/01/06/EVM/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'EVM(以太坊虚拟机)',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/hs-custom.css"><meta name="generator" content="Hexo 8.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/luffy-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Chitian's Blogs</span></a><a class="nav-page-title" href="/"><span class="site-name">EVM(以太坊虚拟机)</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">EVM(以太坊虚拟机)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-01-06T13:37:36.000Z" title="发表于 2026-01-06 21:37:36">2026-01-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-06T14:06:03.729Z" title="更新于 2026-01-06 22:06:03">2026-01-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/web3/">web3</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span></div></div></div><article class="container post-content" id="article-container"><h1 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h1><p><strong>EVM</strong> 全称是 <strong>Ethereum Virtual Machine</strong> ，具备以下特性：</p>
<ul>
<li><strong>虚拟运行环境：</strong> 它不直接运行在硬件上，而是作为一个软件层运行在每一个以太坊节点（计算机）中。</li>
<li><strong>沙盒化（Sandboxed）：</strong> EVM 是完全隔离的。在 EVM 中运行的代码（智能合约）无法访问网络、文件系统或其他进程。这保证了即使合约有恶意代码，也不会损害节点本身。</li>
<li><strong>统一性：</strong> 无论在 Windows、Linux 还是 macOS 上运行以太坊节点，EVM 的执行结果都是完全一致的。</li>
</ul>
<h1 id="二、工作原理"><a href="#二、工作原理" class="headerlink" title="二、工作原理"></a>二、工作原理</h1><p><img src="/../img/evm.png" alt="evm"></p>
<h2 id="1-代码的编译与执行流程"><a href="#1-代码的编译与执行流程" class="headerlink" title="1. 代码的编译与执行流程"></a>1. 代码的编译与执行流程</h2><ul>
<li><strong>编写：</strong> 开发者写好 Solidity 代码。</li>
<li><strong>编译：</strong> 编译器将代码转换为 <strong>Bytecode（字节码）</strong>。这是 EVM 唯一能读懂的语言（一串十六进制数字）。</li>
<li><strong>部署：</strong> 字节码被作为数据发送到区块链上存储。</li>
<li><strong>执行：</strong> 当用户调用合约时，EVM 读取这些字节码，并将其分解为 <strong>Opcode（操作码）</strong> 逐行执行。</li>
</ul>
<h2 id="2-栈式架构"><a href="#2-栈式架构" class="headerlink" title="2. 栈式架构"></a>2. 栈式架构</h2><p>与我们在个人电脑中常用的 x86 架构（基于寄存器）不同，EVM 是<strong>基于栈（Stack）</strong> 的虚拟机。</p>
<ul>
<li><strong>后进先出 (LIFO)：</strong> 数据像叠盘子一样，最后放进去的数据最先被取出。</li>
<li><strong>操作方式：</strong> EVM 指令（如 <code>ADD</code>）会从栈顶弹出两个数字，相加，然后将结果压回栈顶。</li>
<li><strong>优点：</strong> 这种架构更容易实现，且对指令长度要求更短（不需要指定操作数的地址，默认就在栈顶）。</li>
</ul>
<h2 id="3-数据存储空间"><a href="#3-数据存储空间" class="headerlink" title="3. 数据存储空间"></a>3. 数据存储空间</h2><p>EVM 在执行时有三种主要的数据存储区域，它们的成本和用途各不相同：<br>(这块其实在学习到 solidity 语言的时候会理解的更深刻一些)</p>
<table>
<thead>
<tr>
<th><strong>存储类型</strong></th>
<th><strong>特点</strong></th>
<th><strong>成本 (Gas)</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Stack (栈)</strong></td>
<td>免费、极快，但空间很小（仅1024层）。</td>
<td>低</td>
<td>用于运算过程中的临时变量交换。</td>
</tr>
<tr>
<td><strong>Memory (内存)</strong></td>
<td>临时存储，合约执行完即清空。数据量越大越贵。</td>
<td>中</td>
<td>用于存储函数参数、返回值、临时数组。</td>
</tr>
<tr>
<td><strong>Storage (存储)</strong></td>
<td><strong>永久存储</strong>在区块链上。全网同步，最昂贵。</td>
<td><strong>极高</strong></td>
<td>用于存储合约的状态变量（如用户的代币余额）。</td>
</tr>
</tbody></table>
<h2 id="4-Gas-机制-燃料"><a href="#4-Gas-机制-燃料" class="headerlink" title="4. Gas 机制 (燃料)"></a>4. Gas 机制 (燃料)</h2><p>由于 EVM 是图灵完备的（允许循环），如果有人写了一个死循环（<code>while(true)</code>），全网节点都会卡死。为了解决这个问题（停机问题），以太坊引入了 <strong>Gas</strong>。</p>
<ul>
<li><strong>付费计算：</strong> 每一个 Opcode（如加法、乘法、存储数据）都有固定的 Gas 成本。</li>
<li><strong>耗尽即停：</strong> 交易发送者必须预付 Gas。如果代码执行中 Gas 耗尽，EVM 会立即停止执行，回滚所有状态更改，但<strong>不退还</strong>已消耗的 Gas。</li>
</ul>
<h1 id="三、Opcode"><a href="#三、Opcode" class="headerlink" title="三、Opcode"></a>三、Opcode</h1><p>Opcode 是 EVM 的机器语言，是 1 字节的指令，最多能有 256 个指令（$2^8$），目前以太坊定义了约 140 多个，其余未定义。直接去记0x01 之类的字节码是比较困难的，所以每一个指令都有对应的英文缩写，类似于汇编语言，将 2 进制的 0,1 转换成我们更容易理解的符号而已</p>
<h2 id="1-基础操作指令"><a href="#1-基础操作指令" class="headerlink" title="1. 基础操作指令"></a>1. 基础操作指令</h2><p>Opcode明细在<a target="_blank" rel="noopener" href="https://www.evm.codes/">这里</a>查看</p>
<h3 id="1-栈操作-Stack-Manipulation"><a href="#1-栈操作-Stack-Manipulation" class="headerlink" title="1. 栈操作 (Stack Manipulation)"></a>1. 栈操作 (Stack Manipulation)</h3><p>这是 EVM 最频繁使用的指令，用于数据的搬运。</p>
<table>
<thead>
<tr>
<th><strong>字节码</strong></th>
<th><strong>指令名称</strong></th>
<th><strong>指令解释</strong></th>
<th><strong>基础 Gas</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>0x50</code></td>
<td><strong>POP</strong></td>
<td>从栈顶移除 1 个元素</td>
<td>2</td>
</tr>
<tr>
<td><code>0x60</code></td>
<td><strong>PUSH1</strong></td>
<td>将随后的 1 字节数据压入栈顶</td>
<td>3</td>
</tr>
<tr>
<td><code>0x60</code>…<code>0x7F</code></td>
<td><strong>PUSH1</strong>-<strong>32</strong></td>
<td>将随后的 2~32 字节数据压入栈顶</td>
<td>3</td>
</tr>
<tr>
<td><code>0x80</code></td>
<td><strong>DUP1</strong></td>
<td>复制栈顶第 1 个元素并再次压入栈</td>
<td>3</td>
</tr>
<tr>
<td><code>0x81</code>…<code>0x8F</code></td>
<td><strong>DUP2</strong>-<strong>16</strong></td>
<td>复制栈深处第 N 个元素到栈顶</td>
<td>3</td>
</tr>
<tr>
<td><code>0x90</code></td>
<td><strong>SWAP1</strong></td>
<td>交换栈顶第 1 和第 2 个元素</td>
<td>3</td>
</tr>
<tr>
<td><code>0x91</code>…<code>0x9F</code></td>
<td><strong>SWAP2</strong>-<strong>16</strong></td>
<td>交换栈顶第 1 和第 N+1 个元素</td>
<td>3</td>
</tr>
</tbody></table>
<blockquote>
<p><mark>问题：已知栈元素基本长度就是 32 个字节，只保留 PUSH32 不就可以了么？</mark><br>PUSHN 指令的执行逻辑是 将后面 N 个字节长度的字节码压入栈中</p>
<ul>
<li>用 PUSH1 0x01：字节码占 <code>0x60 0x01</code>（2 字节）</li>
<li>若只有 PUSH32：需要写成 <code>0x7f 0x0000000000000000000000000000000000000000000000000000000000000001</code>（33 字节）</li>
</ul>
<p>字节码的长度变长了，那么需要的Gas 费用也会更高了，已知 200Gas&#x2F;Byte</p>
</blockquote>
<h3 id="2-算术运算-Arithmetic-Operations"><a href="#2-算术运算-Arithmetic-Operations" class="headerlink" title="2. 算术运算 (Arithmetic Operations)"></a>2. 算术运算 (Arithmetic Operations)</h3><p>用于基本的数学计算。</p>
<table>
<thead>
<tr>
<th><strong>字节码</strong></th>
<th><strong>指令名称</strong></th>
<th><strong>指令解释</strong></th>
<th><strong>基础 Gas</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>0x01</code></td>
<td><strong>ADD</strong></td>
<td>加法 (<code>a + b</code>)</td>
<td>3</td>
</tr>
<tr>
<td><code>0x02</code></td>
<td><strong>MUL</strong></td>
<td>乘法 (<code>a * b</code>)</td>
<td>5</td>
</tr>
<tr>
<td><code>0x03</code></td>
<td><strong>SUB</strong></td>
<td>减法 (<code>a - b</code>)</td>
<td>3</td>
</tr>
<tr>
<td><code>0x04</code></td>
<td><strong>DIV</strong></td>
<td>整数除法 (<code>a / b</code>)，分母为0结果为0</td>
<td>5</td>
</tr>
<tr>
<td><code>0x06</code></td>
<td><strong>MOD</strong></td>
<td>取模&#x2F;余数 (<code>a % b</code>)</td>
<td>5</td>
</tr>
<tr>
<td><code>0x0A</code></td>
<td><strong>EXP</strong></td>
<td>指数运算 (<code>a ** exponent</code>)</td>
<td>10 + (50 * 字节数)</td>
</tr>
<tr>
<td><code>0x01</code></td>
<td><strong>ADDMOD</strong></td>
<td>加法取模 <code>(a + b) % N</code></td>
<td>8</td>
</tr>
<tr>
<td><code>0x02</code></td>
<td><strong>MULMOD</strong></td>
<td>乘法取模 <code>(a * b) % N</code></td>
<td>8</td>
</tr>
</tbody></table>
<h3 id="3-比较与逻辑-Comparison-Logic"><a href="#3-比较与逻辑-Comparison-Logic" class="headerlink" title="3. 比较与逻辑 (Comparison &amp; Logic)"></a>3. 比较与逻辑 (Comparison &amp; Logic)</h3><p>结果通常为 <code>1</code> (True) 或 <code>0</code> (False)。</p>
<table>
<thead>
<tr>
<th><strong>字节码</strong></th>
<th><strong>指令名称</strong></th>
<th><strong>指令解释</strong></th>
<th><strong>基础 Gas</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>0x10</code></td>
<td><strong>LT</strong></td>
<td>小于 (<code>a &lt; b</code>)</td>
<td>3</td>
</tr>
<tr>
<td><code>0x11</code></td>
<td><strong>GT</strong></td>
<td>大于 (<code>a &gt; b</code>)</td>
<td>3</td>
</tr>
<tr>
<td><code>0x14</code></td>
<td><strong>EQ</strong></td>
<td>等于 (<code>a == b</code>)</td>
<td>3</td>
</tr>
<tr>
<td><code>0x15</code></td>
<td><strong>ISZERO</strong></td>
<td>是否为零 (<code>a == 0</code>)</td>
<td>3</td>
</tr>
<tr>
<td><code>0x16</code></td>
<td><strong>AND</strong></td>
<td>按位与 (<code>&amp;</code>)</td>
<td>3</td>
</tr>
<tr>
<td><code>0x17</code></td>
<td><strong>OR</strong></td>
<td>按位或 (<code>|</code>)</td>
<td>3</td>
</tr>
<tr>
<td><code>0x19</code></td>
<td><strong>NOT</strong></td>
<td>按位取反 (<code>~</code>)</td>
<td>3</td>
</tr>
</tbody></table>
<h3 id="4-内存与存储-Memory-Storage-最重要且最贵"><a href="#4-内存与存储-Memory-Storage-最重要且最贵" class="headerlink" title="4. 内存与存储 (Memory &amp; Storage) - 最重要且最贵"></a>4. 内存与存储 (Memory &amp; Storage) - <strong>最重要且最贵</strong></h3><p>理解这些指令对优化 Gas 至关重要。</p>
<table>
<thead>
<tr>
<th><strong>字节码</strong></th>
<th><strong>指令名称</strong></th>
<th><strong>指令解释</strong></th>
<th><strong>Gas (估算)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>0x51</code></td>
<td><strong>MLOAD</strong></td>
<td>从内存读取 32 字节</td>
<td>3 + 内存扩展费</td>
</tr>
<tr>
<td><code>0x52</code></td>
<td><strong>MSTORE</strong></td>
<td>向内存写入 32 字节</td>
<td>3 + 内存扩展费</td>
</tr>
<tr>
<td><code>0x53</code></td>
<td><strong>MSTORE8</strong></td>
<td>向内存写入 1 字节</td>
<td>3 + 内存扩展费</td>
</tr>
<tr>
<td><code>0x54</code></td>
<td><strong>SLOAD</strong></td>
<td>从**存储(硬盘)**读取数据</td>
<td><strong>100</strong> (热读) &#x2F; <strong>2100</strong> (冷读)</td>
</tr>
<tr>
<td><code>0x55</code></td>
<td><strong>SSTORE</strong></td>
<td>向**存储(硬盘)**写入数据</td>
<td><strong>2900</strong> (热写) &#x2F; <strong>20000</strong> (新存)</td>
</tr>
<tr>
<td><code>0x20</code></td>
<td><strong>SHA3</strong></td>
<td>计算 Keccak256 哈希值</td>
<td>30 + (6 * 字节数)</td>
</tr>
</tbody></table>
<blockquote>
<p>_注：存储操作（SLOAD&#x2F;SSTORE）的价格会根据 EIP（如 EIP-2929）经常调整，且取决于该槽位是否已被访问过（冷&#x2F;热）。</p>
</blockquote>
<blockquote>
<p><mark>问题：其中的冷热表示什么？</mark><br>在以太坊的底层代码（客户端如 Geth）中，每个交易执行时都会维护一个 <strong>Access List（访问列表&#x2F;缓存集合）</strong>。这里的冷、热由是否使用了 EVM 缓存决定，用到了就是热，否则冷。虽然热操作节省 Gas，但是只能针对单笔交易有效。示例：</p>
<ol>
<li><strong>交易 A</strong> 读取了变量 <code>x</code> -&gt; <strong>冷读</strong>（付 2100）。</li>
<li><strong>交易 A</strong> 再次读取变量 <code>x</code> -&gt; <strong>热读</strong>（付 100）。</li>
<li>(交易 A 结束，区块打包)</li>
<li>(Access List 被清空)</li>
<li><strong>交易 B</strong> 开始，读取变量 <code>x</code> -&gt; <strong>又是冷读</strong>（付 2100）。</li>
</ol>
</blockquote>
<h3 id="5-环境信息-Environmental-Information"><a href="#5-环境信息-Environmental-Information" class="headerlink" title="5. 环境信息 (Environmental Information)"></a>5. 环境信息 (Environmental Information)</h3><p>获取当前交易、区块或发送者的上下文信息。</p>
<table>
<thead>
<tr>
<th><strong>字节码</strong></th>
<th><strong>指令名称</strong></th>
<th><strong>指令解释</strong></th>
<th><strong>基础 Gas</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>0x30</code></td>
<td><strong>ADDRESS</strong></td>
<td>获取当前合约地址 (<code>address(this)</code>)</td>
<td>2</td>
</tr>
<tr>
<td><code>0x31</code></td>
<td><strong>BALANCE</strong></td>
<td>获取某地址余额</td>
<td>100 (热) &#x2F; 2600 (冷)</td>
</tr>
<tr>
<td><code>0x32</code></td>
<td><strong>ORIGIN</strong></td>
<td>交易发起者 (<code>tx.origin</code>)</td>
<td>2</td>
</tr>
<tr>
<td><code>0x33</code></td>
<td><strong>CALLER</strong></td>
<td>直接调用者 (<code>msg.sender</code>)</td>
<td>2</td>
</tr>
<tr>
<td><code>0x34</code></td>
<td><strong>CALLVALUE</strong></td>
<td>随交易发送的 ETH (<code>msg.value</code>)</td>
<td>2</td>
</tr>
<tr>
<td><code>0x36</code></td>
<td><strong>CALLDATASIZE</strong></td>
<td>输入数据的大小</td>
<td>2</td>
</tr>
<tr>
<td><code>0x3A</code></td>
<td><strong>GASPRICE</strong></td>
<td>当前交易 Gas 价格 (<code>tx.gasprice</code>)</td>
<td>2</td>
</tr>
<tr>
<td><code>0x42</code></td>
<td><strong>TIMESTAMP</strong></td>
<td>当前区块时间戳 (<code>block.timestamp</code>)</td>
<td>2</td>
</tr>
</tbody></table>
<h3 id="6-流程控制-Flow-Control"><a href="#6-流程控制-Flow-Control" class="headerlink" title="6. 流程控制 (Flow Control)"></a>6. 流程控制 (Flow Control)</h3><p>决定代码跳转到哪里执行。</p>
<table>
<thead>
<tr>
<th><strong>字节码</strong></th>
<th><strong>指令名称</strong></th>
<th><strong>指令解释</strong></th>
<th><strong>基础 Gas</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>0x56</code></td>
<td><strong>JUMP</strong></td>
<td>无条件跳转到指定位置</td>
<td>8</td>
</tr>
<tr>
<td><code>0x57</code></td>
<td><strong>JUMPI</strong></td>
<td>条件跳转 (<code>if (condition) jump</code>)</td>
<td>10</td>
</tr>
<tr>
<td><code>0x58</code></td>
<td><strong>PC</strong></td>
<td>获取当前程序计数器位置</td>
<td>2</td>
</tr>
<tr>
<td><code>0x5B</code></td>
<td><strong>JUMPDEST</strong></td>
<td>标记一个合法的跳转目的地</td>
<td>1</td>
</tr>
<tr>
<td><code>0x00</code></td>
<td><strong>STOP</strong></td>
<td>停止执行，成功退出</td>
<td>0</td>
</tr>
<tr>
<td><code>0xFD</code></td>
<td><strong>REVERT</strong></td>
<td>停止执行，<strong>回滚状态</strong>，返回数据</td>
<td>0 + 内存消耗</td>
</tr>
<tr>
<td><code>0xF3</code></td>
<td><strong>RETURN</strong></td>
<td>停止执行，<strong>保留状态</strong>，返回数据</td>
<td>0 + 内存消耗</td>
</tr>
</tbody></table>
<h3 id="7-系统操作-System-Operations"><a href="#7-系统操作-System-Operations" class="headerlink" title="7. 系统操作 (System Operations)"></a>7. 系统操作 (System Operations)</h3><p>与其他合约交互。</p>
<table>
<thead>
<tr>
<th><strong>字节码</strong></th>
<th><strong>指令名称</strong></th>
<th><strong>指令解释</strong></th>
<th><strong>基础 Gas</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>0xF0</code></td>
<td><strong>CREATE</strong></td>
<td>创建新合约</td>
<td>32000 + 其它</td>
</tr>
<tr>
<td><code>0xF1</code></td>
<td><strong>CALL</strong></td>
<td>调用其他合约</td>
<td>100 (热) &#x2F; 2600 (冷) + 其它</td>
</tr>
<tr>
<td><code>0xF4</code></td>
<td><strong>DELEGATECALL</strong></td>
<td>委托调用 (保留上下文)</td>
<td>100 (热) &#x2F; 2600 (冷) + 其它</td>
</tr>
<tr>
<td><code>0xFA</code></td>
<td><strong>STATICCALL</strong></td>
<td>静态调用 (不允许修改状态)</td>
<td>100 (热) &#x2F; 2600 (冷) + 其它</td>
</tr>
<tr>
<td><code>0xFF</code></td>
<td><strong>SELFDESTRUCT</strong></td>
<td>销毁合约并发送余额 (已弃用&#x2F;改动)</td>
<td>5000 + 其它</td>
</tr>
</tbody></table>
<h2 id="2-存储差异"><a href="#2-存储差异" class="headerlink" title="2. 存储差异"></a>2. 存储差异</h2><h3 id="Stack（栈）"><a href="#Stack（栈）" class="headerlink" title="Stack（栈）"></a>Stack（栈）</h3><p>在堆栈中，每个元素长度为256位（32字节），最大深度为1024元素，但是每个操作只能操作堆栈顶的16个元素。这也是为什么有时Solidity会报<code>Stack too deep</code>错误。</p>
<blockquote>
<p><mark>问题1 ：为什么最大深度 1024，却只能一次性操作 16 个元素呢？</mark><br>首先，目前能够操作 16 个元素的只有有 SWAP16和 DUP16，如果想要操作第 17 个元素，那么需要增加指令 SWAP17 或 DUP17 了。其次，前面提到过，Opcode 最多有 256 个，资源有限，是十分珍贵的，所以不能随意扩充，而且 16 个元素已经可以满足大部分场景了。<br>聪明的你可能想到了，为什么不能直接定义 SWAP 和 DUP 两个不带数字后缀的指令，然后字节码中该指令后面紧跟着的就代表元素位置呢，相关的法案EIP-663已经在 24 年提出来了，目前还未落实。<br><mark>问题2：Stack too deep 是如何造成的？</mark><br>造成该问题的根本原因，就是仅仅操作 16 个元素无法满足我的代码逻辑的实现了，比如下面的 solidity 程序，函数内部定义了超过 16 个元素的，然后想要访问第 17 个元素就会报错，下面附带了一段程序。<strong>其中很容易想到的优化方式就是把变量从栈移到内存中去即可</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT  </span><br><span class="line">pragma solidity ^0.8.0;  </span><br><span class="line">  </span><br><span class="line">contract StackError &#123;  </span><br><span class="line">    function tooManyVariables() external pure returns (uint) &#123;  </span><br><span class="line">        // 1. 我们开始疯狂往栈里压入变量  </span><br><span class="line">        uint v1 = 1;  </span><br><span class="line">        uint v2 = 2;  </span><br><span class="line">        uint v3 = 3;  </span><br><span class="line">        uint v4 = 4;  </span><br><span class="line">        uint v5 = 5;  </span><br><span class="line">        uint v6 = 6;  </span><br><span class="line">        uint v7 = 7;  </span><br><span class="line">        uint v8 = 8;  </span><br><span class="line">        uint v9 = 9;  </span><br><span class="line">        uint v10 = 10;  </span><br><span class="line">        uint v11 = 11;  </span><br><span class="line">        uint v12 = 12;  </span><br><span class="line">        uint v13 = 13;  </span><br><span class="line">        uint v14 = 14;  </span><br><span class="line">        uint v15 = 15;  </span><br><span class="line">        uint v16 = 16;  </span><br><span class="line">        uint v17 = 17; // 此时，v1 已经被埋到了第 17 层  </span><br><span class="line">  </span><br><span class="line">        // 2. 这里尝试访问 v1, 编译器报错：Stack too deep. Try removing local variables.  </span><br><span class="line">        return v1 + v17;   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Memory（内存）"><a href="#Memory（内存）" class="headerlink" title="Memory（内存）"></a>Memory（内存）</h3><p>堆栈虽然计算高效，但是存储能力有限，因此EVM使用内存来支持交易执行期间的数据存储和读取。EVM的内存是一个线性寻址存储器，可以把它理解为一个动态字节数组，可以根据需要动态扩展。它支持以8或256 bit写入（<code>MSTORE8</code>&#x2F;<code>MSTORE</code>），但只支持以256 bit读取（<code>MLOAD</code>）。</p>
<h3 id="Storage（存储）"><a href="#Storage（存储）" class="headerlink" title="Storage（存储）"></a>Storage（存储）</h3><p>EVM的账户存储（Account Storage）是一种映射（mapping，键值对存储），每个键和值都是256 bit的数据，它支持256 bit的读和写。这种存储在每个合约账户上都存在，并且是持久的，它的数据会保持在区块链上，直到被明确地修改。</p>
<p>对存储的读取（<code>SLOAD</code>）和写入（<code>SSTORE</code>）都需要gas，并且比内存操作更昂贵。这样设计可以防止滥用存储资源，因为所有的存储数据都需要在每个以太坊节点上保存。</p>
<h2 id="3-理解-Opcode-的重要性"><a href="#3-理解-Opcode-的重要性" class="headerlink" title="3. 理解 Opcode 的重要性"></a>3. 理解 Opcode 的重要性</h2><p>平时写 Solidity 不需要直接写 Opcode，但理解它有巨大好处：</p>
<ol>
<li><strong>省钱 (Gas Optimization)：</strong><ul>
<li>知道了 <code>SSTORE</code> 很贵，就会尽量减少写状态变量，改用 <code>Memory</code> 里的变量做中间计算，最后一次性写入 <code>Storage</code>。  </li>
<li>知道 <code>0</code> 值和 <code>非0</code> 值处理成本不同，就会注意变量初始化。</li>
</ul>
</li>
<li><strong>理解黑客攻击：</strong><ul>
<li>很多攻击（如 Reentrancy 重入攻击）在 Solidity 层面看很抽象，但在 Opcode 执行流层面（<code>CALL</code> 之后控制权移交，然后再次 <code>CALL</code>）就非常清晰。</li>
</ul>
</li>
<li><strong>内联汇编 (Inline Assembly)：</strong><ul>
<li>在 Solidity 里可以使用 <code>assembly { ... }</code> 直接写 Opcode。这能绕过 Solidity 的一些限制，或者做极致的性能优化。</li>
</ul>
</li>
</ol>
<h3 id="优化示例"><a href="#优化示例" class="headerlink" title="优化示例"></a>优化示例</h3><h3 id="A-绕过数组边界检查-Bypassing-Array-Bounds-Check"><a href="#A-绕过数组边界检查-Bypassing-Array-Bounds-Check" class="headerlink" title="A. 绕过数组边界检查 (Bypassing Array Bounds Check)"></a>A. 绕过数组边界检查 (Bypassing Array Bounds Check)</h3><p>在 Solidity 中，每次访问数组元素 <code>arr[i]</code>，编译器都会自动插入一段 Opcode 来检查 <code>i &lt; arr.length</code>。如果在 <code>for</code> 循环中，这个检查会重复执行无数次，浪费大量 Gas。</p>
<p><strong>优化原理：</strong> 使用汇编直接计算内存地址并读取，跳过检查。</p>
<h4 id="普通-Solidity-写法："><a href="#普通-Solidity-写法：" class="headerlink" title="普通 Solidity 写法："></a>普通 Solidity 写法：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function sumSolidity(uint[] memory arr) external pure returns (uint sum) &#123;</span><br><span class="line">    for (uint i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        // 每次访问 arr[i] 都要检查 i 是否越界</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Opcode-优化写法："><a href="#Opcode-优化写法：" class="headerlink" title="Opcode 优化写法："></a>Opcode 优化写法：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function sumAssembly(uint[] memory arr) external pure returns (uint sum) &#123;</span><br><span class="line">    assembly &#123;</span><br><span class="line">        // 1. 获取数组长度</span><br><span class="line">        // 在内存中，数组变量 arr 指向的位置存储的是长度</span><br><span class="line">        let len := mload(arr)</span><br><span class="line"></span><br><span class="line">        // 2. 获取数据开始的内存指针</span><br><span class="line">        // 数据从 arr + 32 字节开始</span><br><span class="line">        let dataPtr := add(arr, 0x20)</span><br><span class="line"></span><br><span class="line">        // 3. 循环</span><br><span class="line">        for &#123; let i := 0 &#125; lt(i, len) &#123; i := add(i, 1) &#125; &#123;</span><br><span class="line">            // 计算当前元素的地址：dataPtr + i * 32</span><br><span class="line">            // 读取该地址的值，累加到 sum</span><br><span class="line">            sum := add(sum, mload(add(dataPtr, mul(i, 0x20))))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>收益：</strong> 在大循环中，每次迭代可节省约 <strong>100-200 Gas</strong></p>
<hr>
<h3 id="2-利用草稿区避免内存分配"><a href="#2-利用草稿区避免内存分配" class="headerlink" title="2. 利用草稿区避免内存分配"></a>2. 利用草稿区避免内存分配</h3><p>Solidity 的 <code>string</code> 和 <code>bytes</code> 类型非常昂贵，因为它们涉及大量的内存复制，如果设计内存空间不大，可以直接在草稿区操作</p>
<p><strong>场景：</strong> 比如需要哈希两个输入参数。</p>
<h4 id="普通-Solidity-写法：-1"><a href="#普通-Solidity-写法：-1" class="headerlink" title="普通 Solidity 写法："></a>普通 Solidity 写法：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 数据会先被复制到 Memory，产生内存扩展费和复制费</span><br><span class="line">function hashSolidity(uint a, uint b) external pure returns (bytes32) &#123;</span><br><span class="line">    return keccak256(abi.encodePacked(a, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Opcode-优化写法：-1"><a href="#Opcode-优化写法：-1" class="headerlink" title="Opcode 优化写法："></a>Opcode 优化写法：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function hashAssembly(uint a, uint b) external pure returns (bytes32 result) &#123;</span><br><span class="line">    assembly &#123;</span><br><span class="line">        // 1. 利用 Scratch Space (0x00 - 0x40)</span><br><span class="line">        // 这是一个专门给哈希计算用的临时草稿区，不需要分配内存</span><br><span class="line">        </span><br><span class="line">        mstore(0x00, a) // 把 a 写入内存 0x00</span><br><span class="line">        mstore(0x20, b) // 把 b 写入内存 0x20</span><br><span class="line">        </span><br><span class="line">        // 2. 直接哈希这 64 字节</span><br><span class="line">        result := keccak256(0x00, 0x40)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>收益：</strong> 节省了 <code>abi.encodePacked</code> 带来的内存分配（MSTORE）和指针移动开销，且没有触碰 Free Memory Pointer。</p>
<hr>
<h3 id="3-判断是否为合约地址-isContract"><a href="#3-判断是否为合约地址-isContract" class="headerlink" title="3. 判断是否为合约地址 (isContract)"></a>3. 判断是否为合约地址 (isContract)</h3><p>这是一个非常常见的检查。Solidity 标准库通常会用 <code>addr.code.length &gt; 0</code>。</p>
<h4 id="普通-Solidity-写法：-2"><a href="#普通-Solidity-写法：-2" class="headerlink" title="普通 Solidity 写法："></a>普通 Solidity 写法：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isContract(address account) external view returns (bool) &#123;</span><br><span class="line">    return account.code.length &gt; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Opcode-优化写法：-2"><a href="#Opcode-优化写法：-2" class="headerlink" title="Opcode 优化写法："></a>Opcode 优化写法：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function isContractAssembly(address account) external view returns (bool result) &#123;</span><br><span class="line">    assembly &#123;</span><br><span class="line">        // extcodesize 是一个直接的 Opcode，获取目标地址的代码大小</span><br><span class="line">        // gt 是 greater than (&gt;)</span><br><span class="line">        result := gt(extcodesize(account), 0)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>收益：</strong> 避免了 Solidity 包装器带来的一些栈操作和类型转换开销，更加直接。</p>
<hr>
<blockquote>
<p>方式很多，不一一列举了….</p>
</blockquote>
<h1 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h1><ol>
<li><a target="_blank" rel="noopener" href="https://www.wtf.academy/en/course/WTF-EVM-Opcodes/HelloOpcodes">WTF 学院的 Opcodes 教程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.evm.codes/playground">模拟 Opcode 执行</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://chitian-victor.github.io">chitian-victor</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://chitian-victor.github.io/2026/01/06/EVM/">https://chitian-victor.github.io/2026/01/06/EVM/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://chitian-victor.github.io" target="_blank">Chitian's Blogs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/web3/">web3</a><a class="post-meta__tags" href="/tags/ethereum/">ethereum</a></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2026/01/03/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Hello World</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting  Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1$ hexo server  More info: Server Generate static files1$ hexo generate  More info: Generating Deploy to remote sites1$ hexo deploy  More info: Deployment </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/luffy-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">chitian-victor</div><div class="author-info-description">珍惜每一天，享受每一天～</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/chitian-victor"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/chitian-victor" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://space.bilibili.com/51815484" target="_blank" title="Bilibili"><i class="fab fa-bilibili" style="color: #FA7299;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%AE%9A%E4%B9%89"><span class="toc-number">1.</span> <span class="toc-text">一、定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">二、工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">1. 代码的编译与执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A0%88%E5%BC%8F%E6%9E%B6%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">2. 栈式架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">2.3.</span> <span class="toc-text">3. 数据存储空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Gas-%E6%9C%BA%E5%88%B6-%E7%87%83%E6%96%99"><span class="toc-number">2.4.</span> <span class="toc-text">4. Gas 机制 (燃料)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Opcode"><span class="toc-number">3.</span> <span class="toc-text">三、Opcode</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="toc-number">3.1.</span> <span class="toc-text">1. 基础操作指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%88%E6%93%8D%E4%BD%9C-Stack-Manipulation"><span class="toc-number">3.1.1.</span> <span class="toc-text">1. 栈操作 (Stack Manipulation)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97-Arithmetic-Operations"><span class="toc-number">3.1.2.</span> <span class="toc-text">2. 算术运算 (Arithmetic Operations)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%AF%94%E8%BE%83%E4%B8%8E%E9%80%BB%E8%BE%91-Comparison-Logic"><span class="toc-number">3.1.3.</span> <span class="toc-text">3. 比较与逻辑 (Comparison &amp; Logic)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%86%85%E5%AD%98%E4%B8%8E%E5%AD%98%E5%82%A8-Memory-Storage-%E6%9C%80%E9%87%8D%E8%A6%81%E4%B8%94%E6%9C%80%E8%B4%B5"><span class="toc-number">3.1.4.</span> <span class="toc-text">4. 内存与存储 (Memory &amp; Storage) - 最重要且最贵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%8E%AF%E5%A2%83%E4%BF%A1%E6%81%AF-Environmental-Information"><span class="toc-number">3.1.5.</span> <span class="toc-text">5. 环境信息 (Environmental Information)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6-Flow-Control"><span class="toc-number">3.1.6.</span> <span class="toc-text">6. 流程控制 (Flow Control)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C-System-Operations"><span class="toc-number">3.1.7.</span> <span class="toc-text">7. 系统操作 (System Operations)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AD%98%E5%82%A8%E5%B7%AE%E5%BC%82"><span class="toc-number">3.2.</span> <span class="toc-text">2. 存储差异</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Stack%EF%BC%88%E6%A0%88%EF%BC%89"><span class="toc-number">3.2.1.</span> <span class="toc-text">Stack（栈）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory%EF%BC%88%E5%86%85%E5%AD%98%EF%BC%89"><span class="toc-number">3.2.2.</span> <span class="toc-text">Memory（内存）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Storage%EF%BC%88%E5%AD%98%E5%82%A8%EF%BC%89"><span class="toc-number">3.2.3.</span> <span class="toc-text">Storage（存储）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%90%86%E8%A7%A3-Opcode-%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">3.3.</span> <span class="toc-text">3. 理解 Opcode 的重要性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.3.1.</span> <span class="toc-text">优化示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E7%BB%95%E8%BF%87%E6%95%B0%E7%BB%84%E8%BE%B9%E7%95%8C%E6%A3%80%E6%9F%A5-Bypassing-Array-Bounds-Check"><span class="toc-number">3.3.2.</span> <span class="toc-text">A. 绕过数组边界检查 (Bypassing Array Bounds Check)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A-Solidity-%E5%86%99%E6%B3%95%EF%BC%9A"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">普通 Solidity 写法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Opcode-%E4%BC%98%E5%8C%96%E5%86%99%E6%B3%95%EF%BC%9A"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">Opcode 优化写法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%A9%E7%94%A8%E8%8D%89%E7%A8%BF%E5%8C%BA%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">3.3.3.</span> <span class="toc-text">2. 利用草稿区避免内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A-Solidity-%E5%86%99%E6%B3%95%EF%BC%9A-1"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">普通 Solidity 写法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Opcode-%E4%BC%98%E5%8C%96%E5%86%99%E6%B3%95%EF%BC%9A-1"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">Opcode 优化写法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%90%88%E7%BA%A6%E5%9C%B0%E5%9D%80-isContract"><span class="toc-number">3.3.4.</span> <span class="toc-text">3. 判断是否为合约地址 (isContract)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A-Solidity-%E5%86%99%E6%B3%95%EF%BC%9A-2"><span class="toc-number">3.3.4.1.</span> <span class="toc-text">普通 Solidity 写法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Opcode-%E4%BC%98%E5%8C%96%E5%86%99%E6%B3%95%EF%BC%9A-2"><span class="toc-number">3.3.4.2.</span> <span class="toc-text">Opcode 优化写法：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">引用：</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/06/EVM/" title="EVM(以太坊虚拟机)">EVM(以太坊虚拟机)</a><time datetime="2026-01-06T13:37:36.000Z" title="发表于 2026-01-06 21:37:36">2026-01-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/03/hello-world/" title="Hello World">Hello World</a><time datetime="2026-01-03T02:00:00.000Z" title="发表于 2026-01-03 10:00:00">2026-01-03</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2026 By chitian-victor</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="/js/tw_cn.js?v=5.5.3"></script><div class="js-pjax"></div></div></body></html>